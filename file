data-privacy-vault/
    handlers/
        detokenize.go
            package handlers

            import (
                "data-privacy-vault/models"
                "data-privacy-vault/storage"
                "data-privacy-vault/utils"
                "encoding/json"
                "net/http"
            )

            func DetokenizeHandler(w http.ResponseWriter, r *http.Request) {
                var token models.Token
                if err := json.NewDecoder(r.Body).Decode(&token); err != nil {
                    http.Error(w, "Invalid request", http.StatusBadRequest)
                    return
                }

                storage.Store.Lock()
                defer storage.Store.Unlock()

                detokenizedData := make(map[string]map[string]interface{})
                flatData := make(map[string]string)

                for key, tokenValue := range token.Data {
                    // Check if the token exists in storage
                    if storedValue, exists := storage.Store.Data[tokenValue]; exists {
                        // Decrypt the stored value
                        decryptedValue, err := utils.Decrypt(storedValue["value"])
                        if err != nil {
                            http.Error(w, "Decryption failed", http.StatusInternalServerError)
                            return
                        }

                        // Add to both detokenizedData (verbose) and flatData (for response)
                        detokenizedData[key] = map[string]interface{}{
                            "found": true,
                            "value": decryptedValue,
                        }
                        flatData[key] = decryptedValue
                    } else {
                        detokenizedData[key] = map[string]interface{}{
                            "found": false,
                            "value": "",
                        }
                        flatData[key] = "" // Default empty string for unmatched tokens
                    }
                }

                response := models.Token{
                    ID:   token.ID,
                    Data: flatData, // Only the flattened map[string]string is returned
                }
                json.NewEncoder(w).Encode(response)
            }
        tokenize.go
            package handlers

            import (
                "data-privacy-vault/models"
                "data-privacy-vault/storage"
                "data-privacy-vault/utils"
                "encoding/json"
                "math/rand"
                "net/http"
            )

            func TokenizeHandler(w http.ResponseWriter, r *http.Request) {
                var token models.Token
                if err := json.NewDecoder(r.Body).Decode(&token); err != nil {
                    http.Error(w, "Invalid request", http.StatusBadRequest)
                    return
                }

                storage.Store.Lock()
                defer storage.Store.Unlock()

                tokenizedData := make(map[string]string)
                for key, value := range token.Data {
                    // Encrypt the value
                    encryptedValue, err := utils.Encrypt(value)
                    if err != nil {
                        http.Error(w, "Encryption failed", http.StatusInternalServerError)
                        return
                    }

                    // Generate a token for the encrypted value
                    tokenizedKey := generateToken()
                    tokenizedData[key] = tokenizedKey

                    // Store the encrypted value with the tokenized key
                    storage.Store.Data[tokenizedKey] = map[string]string{"key": key, "value": encryptedValue}
                }

                token.Data = tokenizedData
                w.WriteHeader(http.StatusCreated)
                json.NewEncoder(w).Encode(token)
            }

            func generateToken() string {
                const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
                b := make([]byte, 8)
                for i := range b {
                    b[i] = charset[rand.Intn(len(charset))]
                }
                return string(b)
            }
    middleware/
        auth.go
            package middleware

            import (
                "net/http"
                "strings"
            )

            // AuthMiddleware ensures that requests are authenticated.
            func AuthMiddleware(next http.Handler) http.Handler {
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                    // Extract Authorization header
                    authHeader := r.Header.Get("Authorization")
                    if authHeader == "" {
                        http.Error(w, "Unauthorized: Missing Authorization header", http.StatusUnauthorized)
                        return
                    }

                    // Check the token format and value
                    parts := strings.Split(authHeader, " ")
                    if len(parts) != 2 || parts[0] != "Bearer" || !validateToken(parts[1]) {
                        http.Error(w, "Unauthorized: Invalid token", http.StatusUnauthorized)
                        return
                    }

                    // If valid, pass control to the next handler
                    next.ServeHTTP(w, r)
                })
            }

            // A dummy token validation function (replace with your own logic)
            func validateToken(token string) bool {
                // In a real system, you might verify the token against a database or use JWT
                return token == "valid-token"
            }
    models/
        token.go
            package models

            type Token struct {
                ID   string            `json:"id"`
                Data map[string]string `json:"data"`
            }
    storage/
        memory.go
            package storage

            import "sync"

            type MemoryStore struct {
                sync.Mutex
                Data map[string]map[string]string
            }

            var Store = &MemoryStore{
                Data: make(map[string]map[string]string),
            }
    utils/
        encryption.go
            package utils

            import (
                "crypto/aes"
                "crypto/cipher"
                "crypto/rand"
                "encoding/hex"
                "errors"
                "io"
            )

            // Key must be 16, 24, or 32 bytes to select AES-128, AES-192, or AES-256.
            var key = []byte("examplekey123456") // Replace with a secure key

            // Encrypt encrypts plaintext using AES and returns a hex-encoded ciphertext.
            func Encrypt(plaintext string) (string, error) {
                block, err := aes.NewCipher(key)
                if err != nil {
                    return "", err
                }

                ciphertext := make([]byte, aes.BlockSize+len(plaintext))
                iv := ciphertext[:aes.BlockSize]
                if _, err := io.ReadFull(rand.Reader, iv); err != nil {
                    return "", err
                }

                stream := cipher.NewCFBEncrypter(block, iv)
                stream.XORKeyStream(ciphertext[aes.BlockSize:], []byte(plaintext))

                return hex.EncodeToString(ciphertext), nil
            }

            // Decrypt decrypts a hex-encoded ciphertext using AES and returns the plaintext.
            func Decrypt(ciphertext string) (string, error) {
                data, err := hex.DecodeString(ciphertext)
                if err != nil {
                    return "", err
                }

                block, err := aes.NewCipher(key)
                if err != nil {
                    return "", err
                }

                if len(data) < aes.BlockSize {
                    return "", errors.New("ciphertext too short")
                }

                iv := data[:aes.BlockSize]
                data = data[aes.BlockSize:]

                stream := cipher.NewCFBDecrypter(block, iv)
                stream.XORKeyStream(data, data)

                return string(data), nil
            }
    main.go
        package main

        import (
            "data-privacy-vault/handlers"
            "data-privacy-vault/middleware"
            "net/http"
        )

        func main() {
            // Use AuthMiddleware to secure the /tokenize and /detokenize endpoints
            http.Handle("/tokenize", middleware.AuthMiddleware(http.HandlerFunc(handlers.TokenizeHandler)))
            http.Handle("/detokenize", middleware.AuthMiddleware(http.HandlerFunc(handlers.DetokenizeHandler)))

            // Start the HTTP server
            http.ListenAndServe(":8080", nil)
        }